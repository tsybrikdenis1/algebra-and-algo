# algebra-and-algo
Алгебраические методы в информатике 

## Задание 1: параллельное вычисление префиксов «произведения»
На лекции для построения схемы логарифмической глубины для сложения чисел в двоичной записи мы использовали схему «параллельный префикс»: быстрое одновременное вычисление всех выражений вида $a_1 \circ a_2 \circ ... \circ a_k$ $(k=1, 2, ..., n)$ 
для бинарной ассоциативной операции $\circ$ и произвольных 
$a_1, a_2, ..., a_n$. Вам предлагается реализовать такую схему, где в качестве $\circ$ выступает дизъюнкция $\lor$. Соответственно, в качестве функциональных элементов допускается использовать только двухвходовую дизъюнкцию (OR). Входы схемы с номерами $0,1,...,n-1$ соответствуют значениям $a_1, a_2, ..., a_n$, а выходы схемы с номерами $ 0,1,\dots,n-1$ соответствуют выражениям $a_1,\,a_1\lor a_2,\,a_1\lor a_2\lor a_3,\,\dots$


## Задание 2: 3-2-трюк
На лекции для построения схемы логарифмической глубины для умножения чисел в двоичной записи мы использовали «3-2-трюк»: быстрое построение по тройке чисел пары чисел, такой, что сумма пары равняется сумме тройки. 
Вам предлагается реализовать схему, которая осуществляет указанное преобразование. На входе схемы $3 n-$битовых значений (в схеме они имеют номера соответственно от $0$ до $3n-1$), 
в таком порядке: $a_0,\,\dots,\,a_{n-1}, b_0,\,\dots,\,b_{n-1}b , c_0,\,\dots,\,c_{n-1}$. 

Эти значения кодируют соответственно числа $A,\,B,\,C$; при этом $a_0,\,b_0,\,c_0$a — это самые младшие разряды двоичных записей, а $a_{n-1},\,b_{n-1},\,c_{n-1}$  — самые старшие. В схеме ровно $2\cdot(n+1)$ вершин должны быть помечены как выходные и соответствовать битовым записям $x_0,\,\dots,\,x_n$ и $y_0,\,\dots,\,y_n$(именно в таком порядке, т.е., например, выходу схемы с порядковым номером $n+2$ соответствует бит $y_1$) чисел $X$ и $Y$, таких, что $X+Y=A+B+C$. В качестве функциональных элементов допускается использовать: отрицание (NOT), двухвходовую конъюнкцию (AND), двухвходовую дизъюнкцию (OR).


## Задание 3: Универсальный многополюсник
Описание задания
Требуется написать программу, которая строит оптимальный универсальный многополюсник от nn переменных в базисе из $\{\lor,\,\land,\,\neg\}$. Универсальный многополюсник — это схема, которая реализует все функции от заданного числа переменных. Количество функциональных элементов в схеме должно быть равно $\left(2^{2^n}-n\right)$, каждая из вершин схемы должна быть помечена как один из выходов. Внимание: входные вершины схемы (имеющие номера от $0$ до $n-1$), в которых нет функциональных элементов, также должны быть помечены как выходы. Как именно занумерованы выходы схемы, не важно.

Вершины нумеруются, начиная с нулевой. Если схема реализует функцию/функции от nn переменных, то вершины с наименьшими nn номерами считаются входами. На выходе программа должна выдать описание схемы; формат описания схемы точно такой же, как и в предыдущем задании.

Входные данные — единственное число $n,\,1\le n\le 3n$.


## Задание 4: Aлгоритм Штрассена + быстрое возведение в степень
Требуется написать программу, возводящую матрицу размера $A\in\mathbb{Z}_9^{n\times n}$ в степень $n$. Число $n$ может не быть степенью двойки (в этом случае можно дополнить матрицу в самом начале алгоритма «углом единичной матрицы»). Для умножения матриц нужно использовать алгоритм Штрассена со сложностью $O(n^{\log_27})$, а для возведения в степень — алгоритм, требующий $O(\log n)$матричных умножений (либо другой алгоритм того же порядка сложности, дав ссылку на него в комментарии в коде). Вся арифметика производится над $\mathbb{Z}_9$ , то есть, например $5+6=2;$ $3\cdot 7=3;$ $4-8=5$ и т.п..


## Задание 5: совершенное паросочетание
Требуется написать программу, которая с помощью вероятностного алгоритма (оценка вероятности ошибки которого основана на лемме Липтона—деМилло—Шварца—Зиппеля) проверяет, есть ли в заданном графе совершенное паросочетание. На самом деле, считать определитель необязательно: достаточно любым относительно быстрым способом проверить невырожденность соответствующей матрицы, ведь для ответа в задаче нужна только эта информация; можно воспользоваться обычным исключением Гаусса. ВАЖНО! Как мы обсуждали на лекции, чтобы ошибки округления/переполнения не приводили к ложному положительному ответу, нужно работать не с числами с плавающей точкой, а с вычетами по какому-нибудь достаточно большому простому модулю. Это обязательное требование к программе.

На вход (из стандартного потока ввода) подаётся список рёбер двудольного графа без изолированных вершин с равномощными долями. Вершины каждой доли графа занумерованы последовательными целыми неотрицательными числами, начиная с нуля. Формат входа:
```
<количество рёбер>
<номер вершины из левой доли> <номер вершины из правой доли>
…
<номер вершины из левой доли> <номер вершины из правой доли>
```
Программа должна вывести в стандартный поток вывода единственное слово ```yes```, если в графе есть совершенное паросочетание, и ```no``` в противном случае. Общее количество вершин графа не превосходит 200.


## Задание 7: Конструкция Пэли и коды Боуза—Шриханде
Реализуйте алгоритм построения кодов Боуза—Шриханде второго типа, которые построены по матрице Адамара, построенной в свою очередь на основе конструкции Пэли. На вход программы подаётся единственное целое число $n$. Гарантируется, что $n$ делится на 4 без остатка, и что $(n-1)$ — простое число. Программа должна выдать $2n$ строчек длины $n$, содержащих нули и единицы. Строчки должны быть все различны, причём количество различных позиций в любой паре различных строчек должно быть не менее $n/2$.

Вычислительной оптимальности не требуется, но полезно, например, предвычислить таблицу значений символа Лежандра.


## Задание 8: Вершинное покрытие графа
Реализуйте приближённый алгоритм поиска минимального взвешенного вершинного покрытия графа (ошибающийся по весу не более чем вдвое) на основе описанной на лекции схемы «решаем задачу ЛП и округляем». Использовать решение задачи ЛП обязательно. В программах допускается (и рекомендуется) не реализовывать самостоятельно, а использовать сторонние решатели задачи ЛП, доступные на Stepik. В частности, на Python допускается использовать ```scipy.optimize.linprog```. Рекомендуется в этом случае пользоваться разреженными матрицами ```dok_matrix``` и указывать параметр ```linprog(…, method='interior-point', options={"sparse":True, "tol": 1e-2})```.

На вход программы подаются веса вершин и рёбра в виде:
```
<количество вершин N>
<вес вершины 0>
…
<вес вершины (N-1)>
<количество рёбер>
<id начала ребра> <id конца ребра>
<id начала ребра> <id конца ребра> 
…
```
Веса вершин — положительные целые числа. Выход программы — разделённые пробельными символами номера вершин, включённых в покрытие.


## Задание 10: Разрез минимальной плотности

Реализуйте приближённый алгоритм поиска разреза минимальной плотности (алгоритм на основе собственного вектора, соответствующего второму по величине собственному значению лапласиана графа). На вход программы подаются рёбра неориентированного графа в виде:

```
<количество рёбер>
<id начала ребра> <id конца ребра>
<id начала ребра> <id конца ребра> 
…
```

id вершин — натуральные числа (необязательно последовательные), изолированных вершин нет. Выход программы — разделённые пробельными символами и упорядоченные по возрастанию номера вершин, включённых в наименьшую по мощности компоненту разреза. Если есть разные полученные в строгом соответствии с алгоритмом ответы, имеющие одинаковую плотность, то нужно вывести лексикографически минимальный из них. (Минимальный как список чисел, а не как строку, например, из разрезов “1 2 3 112” и “1 2 3 12” нужно вывести именно “1 2 3 12”.)

При использовании библиотеки numpy рекомендуется использовать функцию eigh, «заточенную» специально под эрмитовы матрицы.


## Задание 11: 3-однородные множества и задача $3_{\ge 7/8}$ ‑ВЫПОЛНИМОСТЬ
Реализуйте алгоритм, который, используя построенное на лекции 3-однородное множество наборов, находит решение задачи $3_{\ge 7/8}$‑ВЫПОЛНИМОСТЬ.

На вход программы подаются через пробел два числа $n$ и $m$ — число переменных и число скобок соответственно, а далее подаются $m$ строк, кодирующих клаузы, в формате:

```
<neg>var1 <neg>var2 <neg>var3
…
```

где на месте ```<neg>``` может быть либо пустая строка, либо дефис, который означает отрицание соответствующей переменной. При этом на месте var1/var2/var3 стоят числа от $1$ до $n$.

На выходе программа выдаёт единственную строку, содержащую без пробелов информацию о том, какие битовые значения можно присвоить переменным, так, чтобы как минимум $\frac{7}{8}\cdot m$  клауз обратились в единицу (true). Проследите, что используемая для построения однородного множества наборов матрица в точности такая, как описано в лекции: столбцы упорядочены лексикографически; каждый столбец начинается с единицы, за которой следует двоичная запись номера столбца; нумерация ведётся с нуля.

Ограничения задачи: $2\le n\le 1024$, $1\le m\le 10000$.

## Задание 12: Алгоритмы подсчёта попарных расстояний на основе матричного умножения — Seidel
Реализуйте вычисление попарных расстояний между вершинами неориентированного невзвешенного графа с помощью алгоритма Зейделя. На входе программы список рёбер неориентированного графа (через пробел). Вершины графа — целые числа, необязательно последовательные. Гарантируется, что граф связный. Не используйте явно псевдокод из Википедии, чтобы избежать ложноположительных срабатываний автопроверки на плагиат. Ознакомьтесь с теорией алгоритма Зейделя, а затем напишите свой код «из головы».

Программа должна выдать список возможных попарных расстояний и для каждого расстояния через пробел количество неупорядоченных пар различных вершин, находящихся ровно на таком расстоянии. См. примеры.

Ваш алгоритм должен иметь теоретическую оценку сложности $O(n^{2.9})$, что можно достичь, используя внутри алгоритма Зайделя быстрое умножение матриц.
